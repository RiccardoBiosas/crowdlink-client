pragma solidity ^0.5.16;
import "../node_modules/@openzeppelin/contracts/ownership/Ownable.sol";
import "../node_modules/@openzeppelin/contracts/math/SafeMath.sol";


contract CrowdlinkReferral is Ownable {
    using SafeMath for uint256;

    struct Influencer {
        address addr; //influencer public key
        address owner_address; //referral campaign's owner address
        string owner_website; // website to which the marketing URL is connected
        uint256 reward; //influencer reward
        string referral_link; //influencer referral link generated by the shilling company & our API
    }

    struct ReferralCampaign {
        string website;
        uint256 campaignBudget;
        uint256 campaignReward;
        string[] referral_campaign_referral_links_list;
        bool isActive;
        uint256 remainingBudget;
    }

    mapping(string => Influencer) public influencers; // map referral_links to influencers -> one to one relationship
    // mapping(address => uint256) public campaign_owner_balance; //referral campaign owner's balance
    mapping(address => uint256) public account_balance; //referral campaign owner's balance
    mapping(address => ReferralCampaign[]) public referral_campaign_collection; //lists of referral campaigns associated to an address

    function addInfluencer(
        string memory _website,
        string memory _referral_link,
        address _owner
    ) public returns (bool) {
        (
            uint256 referral_campaign_indx,
            bool found
        ) = helper_selectReferralCampaign(_owner, _website);
        //also check if it's still isActive

        if (found) {

                uint256 reward
             = referral_campaign_collection[_owner][referral_campaign_indx]
                .campaignReward;

            Influencer memory influencer_instance;

            influencer_instance.addr = msg.sender;
            influencer_instance.owner_address = _owner;
            influencer_instance.owner_website = _website;
            influencer_instance.reward = reward;
            influencer_instance.referral_link = _referral_link;

            influencers[_referral_link] = influencer_instance;
            referral_campaign_collection[_owner][referral_campaign_indx]
                .referral_campaign_referral_links_list
                .push(_referral_link);

            return true;
        } else {
            return false;
        }
    }

    function openReferralCampaign(
        uint256 _campaignBudget,
        uint256 _campaignReward,
        string memory _website
    ) public payable returns (uint256) {
        require(
            msg.value == _campaignBudget &&
                (account_balance[msg.sender] + msg.value) >
                account_balance[msg.sender]
        );

        ReferralCampaign memory referral_campaign_instance;
        referral_campaign_instance.website = _website;
        referral_campaign_instance.campaignBudget = _campaignBudget;
        referral_campaign_instance.campaignReward = _campaignReward;
        referral_campaign_instance.isActive = true;
        referral_campaign_instance.remainingBudget = _campaignBudget;

        account_balance[msg.sender] = account_balance[msg.sender].add(
            msg.value
        );
        referral_campaign_collection[msg.sender].push(
            referral_campaign_instance
        );
        return account_balance[msg.sender];
    }

    function getBalanceOfInfluencer(string memory _link)
        public
        view
        returns (uint256)
    {
        Influencer storage influencer_instance = influencers[_link];
        string memory influencer_instance_link = influencer_instance
            .referral_link;
        if (helper_compareStrings(influencer_instance_link, _link)) {
            address influencer_addr = address(influencer_instance.addr);
            return influencer_addr.balance;
        }
        return 0;
    }

    function forwardRewards(
        string memory _referral_link,
        string memory _website,
        address _from,
        address _to
    )
        public
        returns (uint256 _campaign_owner_balance, uint256 _influencer_balance)
    {
        //add isOwner modifier
        (
            uint256 referral_campaign_indx,
            bool found
        ) = helper_selectReferralCampaign(_from, _website);

        require(
            found == true &&
                account_balance[_from] > influencers[_referral_link].reward &&
                referral_campaign_collection[_from][referral_campaign_indx]
                    .isActive ==
                true &&
                (account_balance[_from] - influencers[_referral_link].reward) <
                account_balance[_from]
        );

        if (
            referral_campaign_collection[_from][referral_campaign_indx]
                .remainingBudget > influencers[_referral_link].reward
        ) {
            referral_campaign_collection[_from][referral_campaign_indx]
                .remainingBudget = referral_campaign_collection[_from][referral_campaign_indx]
                .remainingBudget
                .sub(influencers[_referral_link].reward);
            account_balance[_from] = account_balance[_from].sub(
                influencers[_referral_link].reward
            );
            account_balance[_to] = account_balance[_to].add(
                influencers[_referral_link].reward
            );

            return (account_balance[_from], account_balance[_to]);
        } else {
            referral_campaign_collection[_from][referral_campaign_indx]
                .isActive = false; //should you remove a campaign once it's not active anymore?
            return (account_balance[_from], account_balance[_to]);
        }
    }

    function withdrawFromCampaign(string memory _website)
        public
        payable
        returns (uint256)
    {
        (
            uint256 referral_campaign_indx,
            bool found
        ) = helper_selectReferralCampaign(msg.sender, _website);

        require(
            found == true &&
                referral_campaign_collection[msg.sender][referral_campaign_indx]
                    .remainingBudget >
                0 &&
                account_balance[msg.sender] > 0 &&
                account_balance[msg.sender] >
                referral_campaign_collection[msg.sender][referral_campaign_indx]
                    .remainingBudget
        );
        referral_campaign_collection[msg.sender][referral_campaign_indx]
            .isActive = false;
        account_balance[msg.sender] = account_balance[msg.sender].sub(
            referral_campaign_collection[msg.sender][referral_campaign_indx]
                .remainingBudget
        );
        msg.sender.transfer(
            referral_campaign_collection[msg.sender][referral_campaign_indx]
                .remainingBudget
        );
        referral_campaign_collection[msg.sender][referral_campaign_indx]
            .remainingBudget = 0;

        return account_balance[msg.sender];
    }

    function lookupCampaignReferralsCollectionLength(address _account_address)
        public
        view
        returns (uint256)
    {
        require(
            referral_campaign_collection[_account_address][0].campaignBudget !=
                0
        );
        return referral_campaign_collection[_account_address].length;
    }

    function lookUpCampaignReferral(address _account_address, uint256 _index)
        public
        view
        returns (string memory, uint256, uint256, bool, address[] memory)
    {
        require(
            referral_campaign_collection[_account_address][_index]
                .campaignBudget != 0
        );


            string memory campaign_referral_website
         = referral_campaign_collection[_account_address][_index].website;


            address[] memory referral_campaign_influencers_address_list
         = new address[](
            referral_campaign_collection[_account_address][_index]
                .referral_campaign_referral_links_list
                .length
        ); //length of the array equal to length of the referral campaign's referral links array
        for (
            uint256 i = 0;
            i <
            referral_campaign_collection[_account_address][_index]
                .referral_campaign_referral_links_list
                .length;
            i++
        ) {

                address influencer_addr
             = influencers[referral_campaign_collection[_account_address][_index]
                .referral_campaign_referral_links_list[i]]
                .addr;
            referral_campaign_influencers_address_list[i] = influencer_addr;
        }

        return (
            campaign_referral_website,
            referral_campaign_collection[_account_address][_index]
                .campaignBudget,
            referral_campaign_collection[_account_address][_index]
                .campaignReward,
            referral_campaign_collection[_account_address][_index].isActive,
            referral_campaign_influencers_address_list
        );
    }

    function helper_selectReferralCampaign(
        address _address,
        string memory _website
    ) public view returns (uint256, bool) {
        uint256 indx = 0;
        bool found = false;
        for (
            uint256 i = 0;
            i < referral_campaign_collection[_address].length;
            i++
        ) {
            string memory website = referral_campaign_collection[_address][i]
                .website;
            if (keccak256(bytes(website)) == keccak256(bytes(_website))) {
                indx = i;
                found = true;
            }
        }

        return (indx, found);
    }

    function helper_compareStrings(string memory a, string memory b)
        public
        pure
        returns (bool)
    {
        //probably should be internal
        return (keccak256(abi.encodePacked(a)) ==
            keccak256(abi.encodePacked(b)));
    }
}
